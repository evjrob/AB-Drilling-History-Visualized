---
title: "Alberta Drilling History Visualized"
output:
  html_notebook: default
  html_document: default
date: '2017-05-18'
---

```{r setup, include = FALSE}
library(tidyverse)
library(ggmap)
library(gridExtra)
# My aertidywells package can be installed using: install_github("evjrob/aertidywells")
library(aertidywells)
library(stringr)
library(lubridate)
```

We're going to plot all of the wells ever drilled in Alberta as an animated map. The [data comes from the Alberta Energy Regulator (AER)](https://www.aer.ca/data-and-publications/statistical-reports/st37) and requires the following supporting data files to re-create the full human friendly dataset:

* [Business Asscociate Codes](https://www.aer.ca/data-and-publications/statistical-reports/st104)
    * <http://www.aer.ca/data/codes/BusinessAssociate_Codes.xlsx>
* [Field and Pool Codes](https://www.aer.ca/data-and-publications/statistical-reports/st103)
    * <http://aer.ca/data/codes/FieldList.txt>
    * <http://aer.ca/data/codes/FieldPoolList.txt>
* [Oilsands Area and Deposit Codes](http://www.petrinex.ca/29.asp)
    * <https://www.petrinex.gov.ab.ca/bbreports/PRAOilSandsAreaCodes.csv>
    * <https://www.petrinex.gov.ab.ca/bbreports/PRAOilSandsAreaDepositCodes.csv>

The above files should be stored in a data/ folder within the same directory as this project.

The well list can then be reconstructed:
```{r, results = 'hide'}
wells <- aertidywells::create_well_tibble()
```

The AER does not provide any precise location information for wells within the freely available well list so it is necessary to find and alternative means of placing them spatially. Luckily all wells in Alberta are issued a Unique Well Identifer (UWI) which consists of three main components:
  
  XX/YY-YY-YYY-YYWY/ZZ
  
The **X** components identify in sequential order the wells drilled in a given surface location using the [Dominion Land Survey (DLS)](https://en.wikipedia.org/wiki/Dominion_Land_Survey) coordinate system, the **Y** components identify the location of the bottom of the well in DLS coordinates, and the **Z** components identify the the drilling event for the well indicated by the previous two components.

The **Y** components are the interesting and useful parts for this project. The breakdown of the DLS location is *LSD***-***SEC***-***TWP***-***RNG***W***MER*, defined as follows:

* LSD: Legal Subdivision
* SEC: Section
* TWP: Township
* RNG: Range
* MER: Meridian

It is possible to use the **Y** components of the UWI to approximate the precide location of each well and convert these locations to latitude and longitude for plotting. A means of converting the DLS locations to an easier coordinate systems is required. Unfortunately the process of converting the grid based DLS coordinates to Latitude and Longitude can only be approximate because the Legal Subdivisions of the DLS location we are given typically measure 400m by 400m. 

There are numerous tools to convert DLS locations to other coordinate systems, but most of them are proprietary systems that only allow one query at a time or charge money for bulk conversions. This is largely due to the hisotrically closed and proprietary licensing of the the Alberta Township System (ATS), Alberta's precise version of the DLS system. Luckily the ATS coordinate files are now freely available from the Geospatial data vendor [AltaLIS](http://www.altalis.com/products/property/ats.html). The **ATS V4.1 Coordinate files** should be obtained from AltaLIS and extracted to /data/AltaLIS.
```{r, results = 'hide'}
ats_col_widths <- readr::fwf_widths(c(1, 2,3,2,2,11,12,4,2,2,1,1,1), c("MERIDIAN", "RANGE", "TOWNSHIP", "SECTION", "QUARTER SECTION", "LATITUDE", "LONGITUDE", "YEAR COMPUTED", "MONTH COMPUTED", "DAY COMPUTED", "STATION CODE", "STATUS CODE", "HORIZONTAL CLASSIFICATION"))

ats_col_types <- list(readr::col_character(), # MERIDIAN
                      readr::col_character(), # RANGE
                      readr::col_character(), # TOWNSHIP
                      readr::col_character(), # SECTION
                      readr::col_character(), # QUARTER SECTION
                      readr::col_double(), # LATITUDE
                      readr::col_double(), # LONGITUDE
                      readr::col_integer(), # YEAR COMPUTED
                      readr::col_integer(), # MONTH COMPUTED
                      readr::col_integer(), # DAY COMPUTED
                      readr::col_character(), # STATION CODE
                      readr::col_character(), # STATUS CODE
                      readr::col_character()  # HORIZONTAL CLASSIFICATION
)

ats_location_data <- read_fwf("data/AltaLIS/ATS_V4_1.SEQ", ats_col_widths, col_types = ats_col_types)
```

The above data provided by AltaLIS is not accurate to the level of a single LSD. The finest resolution directly provided are the corners of the quarter sections. The ATS_Coordinate_File_Information.doc describes the precise positioning of these quarter sections.
For our purposes we don't need to be so accurate. If we plot our wells to the level of a section the wells will be placed accurately within 1.6km. That doesn't seem particularly good, but the inaccuracies should be essentially unnoticable at a provincial map scale.

Latitudes and Longitudes can be obtained for each section by grouping the data by each component of the DLS location up to the section and summarizing the latitude and longitude to obtain the mean of all the rows given for each section. 
```{r}
ats_location_data <- ats_location_data %>% group_by(MERIDIAN, RANGE, TOWNSHIP, SECTION) %>% summarise(mean_latitude = mean(LATITUDE), mean_longitude = mean(LONGITUDE))

ats_location_data <- ats_location_data %>% mutate(mean_longitude = -1 * mean_longitude)
```

The DLS location components of the UWI should also be extracted out into their own columns:
```{r}
wells <- wells %>% dplyr::mutate(`SECTION` = stringr::str_sub(`UWI-DISPLAY-FORMAT`, 7, 8))
wells <- wells %>% dplyr::mutate(`TOWNSHIP` = stringr::str_sub(`UWI-DISPLAY-FORMAT`, 10, 12))
wells <- wells %>% dplyr::mutate(`RANGE` = stringr::str_sub(`UWI-DISPLAY-FORMAT`, 14, 15))
wells <- wells %>% dplyr::mutate(`MERIDIAN` = stringr::str_sub(`UWI-DISPLAY-FORMAT`, 17, 17))
```

Now the mean latitude and longitude can now be joined to the wells data set:
```{r}
wells <- wells %>% left_join(ats_location_data %>% select(MERIDIAN, RANGE, TOWNSHIP, SECTION, mean_latitude, mean_longitude))
```

The base map is sourced from Gogle maps using ggmap:
```{r}
ab <- get_map("Alberta", zoom = 5, maptype = "terrain")

```

And the wells should show up nicely on top of this base map:
```{r}
map_boundaries <- attr(ab, "bb")

# The upper and lower boundaries are used to place the date label in the map
label_lon <- (map_boundaries$ur.lon + map_boundaries$ll.lon) / 2
label_lat <- map_boundaries$ur.lat - (map_boundaries$ur.lat - map_boundaries$ll.lat) / 20

date_label_data <- wells %>%
  summarise(
    lon = label_lon,
    lat = label_lat,
    label = "May 20, 1990"
  )

# Plotting a small subset of the wells since plotting all 592,966 of them will take a long time.
wells_May_20_1990 <- wells %>% filter(`FINAL-DRILL-DATE` == ymd("1990-05-20"))

# By creating the base map separate from the points plotted, we will be able to reuse it later in the animation loop.
well_map <- ggmap(ab) +
  theme(legend.position="none") + 
  ggtitle("Wells Drilled in Alberta Over Time") + 
  labs(
    x = "Longitude",
    y = "Latitude"
  )

well_points <- geom_point(data = wells_May_20_1990, aes(x = mean_longitude, y = mean_latitude, color = "red"))
date_label <- geom_text(aes(label = label), data = date_label_data, vjust = "top", hjust = "left")

well_map + well_points + date_label
```

It would also be nice to see where the drilling on this day falls in a historical context:
```{r}
date_rect <- data.frame(xmin = ymd("1990-05-20"), xmax = ymd("1990-05-20"), ymin=-Inf, ymax=Inf)
date_range_geom <- geom_rect(data = date_rect, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), color = "dodgerblue1", fill = "dodgerblue1", alpha = 0.4, inherit.aes = FALSE)

well_chart <- ggplot(data = wells) + 
  geom_density(aes(x = `FINAL-DRILL-DATE`), na.rm = TRUE) + 
  theme(legend.position="none", axis.text.y = element_blank()) + 
  ggtitle("") + # The blank title ensures the top of the chart is flush with the map. 
  labs(
    x = "Date Drilled",
    y = "Proportion of All Wells Drilled"
  )


well_chart + date_range_geom
```

And these two plots can be combined into one frame of the eventual animation:
```{r}
# This ratio of the plots was discovered to balance their heights and widths nicely through experimentation.
layout_dims <- rbind(c(1,1,1,2,2),
                     c(1,1,1,2,2))
grid.arrange(well_map + well_points, well_chart + date_range_geom, layout_matrix = layout_dims)
```

Running one frame per day will result in a huge number of frames and a very long animation even at a high frame rate ike 60fps:

```{r}
# days / frames per second / 60 seconds per minute
frames <- as.numeric(difftime(max(wells$`FINAL-DRILL-DATE`, na.rm = TRUE), min(wells$`FINAL-DRILL-DATE`, na.rm = TRUE), units = "days"))
frames / 60 / 60
``` 

An animated gif lasting more than 13 minutes is a bit excessive. Even as a video that is a very long time to spend watching dots dance around on a map. For this reason it's best to start with a smaller subset of the data to test that a shorter animation will turn out as intended. It is also a good idea to allow for the frames per second and the duration of the animation to be defined. Together with the data, these two variables will determine the period of dates encompased by each frame.

```{r}
wells_short <- wells %>% filter(lubridate::year(`FINAL-DRILL-DATE`) > 2013)

# The animation length in seconds
animation_duration <- 3
frames_per_second <- 12
frame_count <- animation_duration * frames_per_second

# The length of time in seconds it should take for a well to fade away
fade_duration <- 0.5
fade_frame_count <- fade_duration * frames_per_second

# Period is the duration in days that each frame of the animation will span
period <- (max(wells_short$`FINAL-DRILL-DATE`, na.rm = T) - min(wells_short$`FINAL-DRILL-DATE`, na.rm = T)) / frame_count

start_date <- min(wells_short$`FINAL-DRILL-DATE`, na.rm = T)

# Frame is the first frame of the animaion in which each well should be shown
wells_short <- wells_short %>% mutate(FRAME = floor((`FINAL-DRILL-DATE` - start_date) / as.double(period, units = 'days')))
```


A simple loop to create the frames for an image sequence:
```{r results='hide', message=FALSE, warning=FALSE}
# The chart can be created outside the loop and reused inside
well_chart <- ggplot(data = wells_short) + 
  geom_density(aes(x = `FINAL-DRILL-DATE`), na.rm = TRUE) + 
  theme(legend.position="none", axis.text.y = element_blank()) + 
  ggtitle("") + # The blank title ensures the top of the chart is flush with the map. 
  labs(
    x = "Date Drilled",
    y = "Proportion of All Wells Drilled"
  )

# Padding the file names with zeros ensures the frames are assembled into the gif in the right order.
filename_padding = floor(log10(frame_count)) + 1

for (frame in 0:frame_count) {
  frame_start_date = start_date + frame * period
  frame_end_date = start_date + (ifelse(frame == frame_count, frame_count, frame + 1)) * period
  
  date_label_data <- wells_short %>%
    summarise(
      lon = label_lon,
      lat = label_lat,
      label = str_c(month(frame_start_date, label = TRUE), " ", year(frame_start_date)) 
    )
  
  frame_wells <- wells_short %>% filter((FRAME >= frame - fade_frame_count) & (FRAME <= frame)) %>% 
    mutate(ALPHA = 1 - (frame - FRAME)/fade_frame_count)
  
  well_points <- geom_point(data = frame_wells, aes(x = mean_longitude, y = mean_latitude, color = "red"), alpha = frame_wells$ALPHA)
  date_label <- geom_text(aes(label = label), data = date_label_data, vjust = "top", hjust = "left")
  
  date_rect <- data.frame(xmin = frame_start_date, xmax = frame_end_date, ymin=-Inf, ymax=Inf)
  date_range_geom <- geom_rect(data = date_rect, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), color = "dodgerblue1", 
                               fill = "dodgerblue1", alpha = 0.4, inherit.aes = FALSE)
  
  frame_grob <- arrangeGrob(well_map + well_points + date_label, well_chart + date_range_geom, layout_matrix = layout_dims)
  
  ggsave(file = str_c("image_sequence/", str_pad(frame, width = filename_padding, side ="left", pad ="0"),".png"), plot = frame_grob)
  
}
```

And then once all the still frame images are created, ffmpeg can be called to turn them into a video file:
```{r results='hide', message=FALSE, warning=FALSE}
system(str_c("ffmpeg -y -framerate ", frames_per_second, " -i 'image_sequence/%02d.png' -s:v 1280x720 -c:v libx264 -profile:v high -crf 20 -pix_fmt yuv420p wells_animation.mp4"))
```

